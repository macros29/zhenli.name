#**************Start with the heart rate estimation less than 150 bpm
#### Need to implement iteration through all segments
pks <- findpeaks(segments[[2]]$conv_data);
prom <- apply(pks, 1, function(xx){xx[1] - max(segments[[2]]$conv_data[xx[3]], segments[[2]]$conv_data[xx[4]])});
#************* Use the 50 to 75 percentiles of the peaks as standards for peak prominence
threshold <- prom[prom > quantile(prom, 0.5) & prom < quantile(prom, 0.75)]
threshold <- mean(threshold) - 5*sd(threshold)
#************* re-peak using threshold
pks <- findpeaks(segments[[2]]$conv_data, minpeakheight = threshold);
# plot(segments[[2]]$data, pch = ".", type = "l")
# points(pks[,2], y = segments[[2]]$data[pks[,2]], type = "p", col = "red")
#************* calculating heart rate
temp_heartrate <- 60*(nrow(pks)) / (segments[[2]]$time[pks[nrow(pks),3]] - segments[[2]]$time[pks[1,3]])
#**************end of heart rate estimation. Note that this estimation is only for choosing standard curve and is not used for final output
#raw_standard <- read.csv('C:/Users/zhenadmin/Onedrive/ViVi Pulse/Data/Code for analysis/raw_standard.csv', header = F)[,1];
raw_standard <- read.csv('C:/Onedrive/ViVi Pulse/Data/Code for analysis/raw_standard.csv', header = F)[,1];
standard <- resample(raw_standard,round((60/temp_heartrate)*samplerate),length(raw_standard));
standard <- standard[25:(length(standard)-25)]
standard = standard/sum(standard);
corr_segment <- c()
for(j in 1:(nrow(segments[[2]]) - length(standard) - 1)){
temp <- segments[[2]]$data[j:(j+length(standard)-1)]
corr_segment <- c(corr_segment, cor(temp, standard))
}
# rev_corr_segment <- c()
# temp <- rev(segments[[2]]$data)
# for(j in length(standard) + 1:(nrow(segments[[2]]) - length(standard))){
#   rev_corr_segment <- c(rev_corr_segment, cor(temp[j:(j+length(standard) - 1)], rev(standard)))
# }
## Find peaks in the correlation map
#*********************use heart rate to set the findpeak condition
samplerate <- 1/mean(segments[[2]]$t_unit)
peak_temp <- findpeaks(corr_segment, minpeakdistance = (60/(temp_heartrate+15))*samplerate);
peak_temp <- peak_temp[order(peak_temp[,2]),]
# rev_peak_temp <- findpeaks(rev(rev_corr_segment),
#                            minpeakdistance = (60/(temp_heartrate+15))*samplerate,
#                            sortstr = F);
# rev_peak_temp <- rev_peak_temp[order(rev_peak_temp[,2]),]
# plot(segments[[2]]$data, pch = ".", type = "l")
# points(peak_temp[,5], y = segments[[2]]$data[peak_temp[,5]], type = "p", col = "red")
#*************this threshold the correlation to be higher than 0.5 as a real peak, changed on 05/09/2017
peak_temp <- peak_temp[peak_temp[,1] > 0.5 & peak_temp[,2] > 50,]
peak_temp <- cbind(peak_temp, (peak_temp[,2] - 50))
colnames(peak_temp) <- c("corr", "peak_loc", "peak_start", "peak_end", "peak_shift")
#plot(segments[[2]]$conv_data[peak_temp[5,5]:peak_temp[6,2]])
pulse_segment <- list()
for(j in 1:(nrow(peak_temp) - 1)){
res <- segments[[2]][ peak_temp[j,5]:peak_temp[j+1,2], ]
if(nrow(res) < (60/(temp_heartrate-15)*samplerate + 100)){ #***************add a step to get rid of multi-peak segments 05/09/2017
pulse_segment[[length(pulse_segment) + 1]] <- res
}
}
#**************adjust the peaks for proper start point 05/09/2017
pulse_segment <- lapply(pulse_segment, function(xx){
a <- rownames(xx)[order(xx$conv_data[1:100])[1]];
n <- (nrow(xx) - 99):nrow(xx);
b <- rownames(xx[n,])[order(xx$conv_data[n])[1]];
n <- which(rownames(xx) == a):which(rownames(xx) == b)
xx[n,]
})
#*******adjust the minimal value to 0  05/25/17
pulse_segment <- lapply(pulse_segment, function(xx){
xx$conv_data <- xx$conv_data - min(xx$conv_data);
xx
})
# col <- rainbow(n = length(pulse_segment))
# plot(pulse_segment[[1]]$conv_data, type = "l", col = col[1], ylim = c(0, 200))
# for(i in 2:length(pulse_segment)){
#   points(pulse_segment[[i]]$conv_data, type = "l", col = col[i])
# }
## parameter fitting!!
#**********************the start point and boudary should use the
#previous days' data, if available. This should really increase
#accuracy.
coef <- lapply(pulse_segment, function(xx){
pulse <- xx
fit_temp_x <- pulse$time - pulse$time[1];
fit_temp_y <- pulse$conv_data;
fit_temp_z <- fit_temp_y+(0-min(fit_temp_y));
x <- fit_temp_x
z <- fit_temp_z
max_amp=max(fit_temp_z);
max_time=max(fit_temp_x);
opts.Lower <- c(0.5*max_amp, 0.3*max_amp, 0.1*max_amp, 0, 0, 0, 0.1*max_time, 0.1*max_time, 0.3*max_time)
opts.StartPoint <- list(a1 = 0.7*max_amp,
a2 = 0.5*max_amp,
a3 = 0.3*max_amp,
b1 = 0.5*max_time/8.65,
b2 = 0.5*max_time/8.65,
b3 = 0.5*max_time/5.7,
c1 = 0.2*max_time,
c2 = 0.3*max_time,
c3 = 0.65*max_time)
opts.Upper <- c(max_amp, max_amp, 0.8*max_amp, max_time/8.65, max_time/8.65, max_time/5.7, 0.3*max_time, 0.5*max_time, 1.0*max_time)
try(fit <- nls(formula = z ~ a1*exp(-0.5*((x-c1)/b1)^2)+
a2*exp(-0.5*((x-c2)/b2)^2)+
a3*exp(-0.5*((x-c3)/b3)^2),
#trace = T,
algorithm = "port",
start = opts.StartPoint,
control = nls.control(maxiter=1000, warnOnly = T),
lower = opts.Lower,
upper = opts.Upper))
# plot(x = fit_temp_x, y = fit_temp_z, type = "l")
# pred_z <- predict(fit, x)
# points(x, pred_z, type = "l", col = "red")
})
rsd <- c()
for(i in 1:length(pulse_segment)){
xx <- pulse_segment[[i]]
x <- xx$time - xx$time[1]
y <- xx$conv_data;
z <- y+(0-min(y))
pred_z <- predict(coef[[i]], x)
pulse_segment[[i]]$pred <- pred_z
coefs <- coefficients(coef[[i]])
pulse_segment[[i]]$gau1 <- coefs['a1']*exp(-0.5*((x-coefs['c1'])/coefs['b1'])^2)
pulse_segment[[i]]$gau2 <- coefs['a2']*exp(-0.5*((x-coefs['c2'])/coefs['b2'])^2)
pulse_segment[[i]]$gau3 <- coefs['a3']*exp(-0.5*((x-coefs['c3'])/coefs['b3'])^2)
corr <- cor(z, pred_z)
rsd <- c(rsd, corr*corr)
}
fit_pulse_segment <- pulse_segment[ !(rsd < 0.95)]
coef <- coef[ !(rsd < 0.95)]
gau1_peak_index <- sapply(fit_pulse_segment, function(xx){
which(xx$gau1 == max(xx$gau1))
})
gau2_peak_index <- sapply(fit_pulse_segment, function(xx){
which(xx$gau2 == max(xx$gau2))
})
P1_diff <- sapply(fit_pulse_segment, function(xx){diff(xx$conv_data)})
P1_index <- c()
for(i in 1:length(fit_pulse_segment)){
xx <- fit_pulse_segment[[i]]
j = 0
for(p in gau1_peak_index[i]:gau2_peak_index[i]){
if(xx$gau1[p] >= xx$gau2[p] & xx$gau1[p+1] <= xx$gau1[p+2]){
j = p+1
break
}
}
if(j == 0){
j = gau1_peak_index[i] + 10;
}
if(length(which(P1_diff[[i]][(gau1_peak_index[i]-5):j] < 0 ))){
P1_ind = which(xx$conv_data == max(xx$conv_data[(gau1_peak_index[i]-5):j]))
} else {
for(p in (gau1_peak_index[i]-5):(gau2_peak_index[i]+50)){
if(P1_diff[[i]][p] < 0){
P1_ind = p-1;
break
}
}
}
if(!(exists("P1_ind"))){
P1_ind = gau2_peak_index[i]+50
}
P1_index <- c(P1_index, P1_ind)
}
#***********Align the curves and calculate average fitted curve
xData=seq(0, 1, by = 0.001)
new.coef <- coef
yData <- rep(0, times = 1001)
for(i in 1:length(coef)){
new.coef[[i]][7:9] <- coefficients(coef[[i]])[7:9] - (P1_index[i]-P1_index[1])*samplerate
new.coef[[i]]['a1']
yData=yData+coefficients(new.coef[[i]])['a1']*exp(-0.5*((xData- coefficients(new.coef[[i]])['c1'])/coefficients(new.coef[[i]])['b1'])^2)+
coefficients(new.coef[[i]])['a2']*exp(-0.5*((xData- coefficients(new.coef[[i]])['c2'])/coefficients(new.coef[[i]])['b2'])^2)+
coefficients(new.coef[[i]])['a3']*exp(-0.5*((xData- coefficients(new.coef[[i]])['c3'])/coefficients(new.coef[[i]])['b3'])^2);
}
ind_standard=yData/length(coef);
## Add one iteration of pulse finding using individual standard
corr_segment_itr <- c()
for(j in 1:(nrow(segments[[2]]) - length(standard) - 1)){
temp <- segments[[2]]$data[j:(j+length(standard)-1)]
corr_segment_itr <- c(corr_segment_itr, cor(temp, standard))
}
## Find peaks in the correlation map
#*********************use heart rate to set the findpeak condition
samplerate <- 1/mean(segments[[2]]$t_unit)
peak_temp <- findpeaks(corr_segment_itr, minpeakdistance = (60/(temp_heartrate+15))*samplerate);
peak_temp <- peak_temp[order(peak_temp[,2]),]
# rev_peak_temp <- findpeaks(rev(rev_corr_segment),
#                            minpeakdistance = (60/(temp_heartrate+15))*samplerate,
#                            sortstr = F);
# rev_peak_temp <- rev_peak_temp[order(rev_peak_temp[,2]),]
# plot(segments[[2]]$data, pch = ".", type = "l")
# points(peak_temp[,5], y = segments[[2]]$data[peak_temp[,5]], type = "p", col = "red")
#*************this threshold the correlation to be higher than 0.6 as a real peak, changed on 05/09/2017
peak_temp <- peak_temp[peak_temp[,1] > 0.6 & peak_temp[,2] > 50,]
peak_temp <- cbind(peak_temp, (peak_temp[,2] - 50))
colnames(peak_temp) <- c("corr", "peak_loc", "peak_start", "peak_end", "peak_shift")
#plot(segments[[2]]$conv_data[peak_temp[5,5]:peak_temp[6,2]])
pulse_segment_itr <- list()
for(j in 1:(nrow(peak_temp) - 1)){
res <- segments[[2]][ peak_temp[j,5]:peak_temp[j+1,2], ]
if(nrow(res) < (60/(temp_heartrate-15)*samplerate + 100)){ #***************add a step to get rid of multi-peak segments 05/09/2017
pulse_segment_itr[[length(pulse_segment_itr) + 1]] <- res
}
}
#**************adjust the peaks for proper start point 05/09/2017
pulse_segment_itr <- lapply(pulse_segment_itr, function(xx){
a <- rownames(xx)[order(xx$conv_data[1:100])[1]];
n <- (nrow(xx) - 99):nrow(xx);
b <- rownames(xx[n,])[order(xx$conv_data[n])[1]];
n <- which(rownames(xx) == a):which(rownames(xx) == b)
xx[n,]
})
#*******adjust the minimal value to 0  05/25/17
pulse_segment_itr <- lapply(pulse_segment_itr, function(xx){
xx$conv_data <- xx$conv_data - min(xx$conv_data);
xx
})
## Curve fitting iteration. 05/10/17
coef_itr <- lapply(pulse_segment_itr, function(xx){
pulse <- xx
fit_temp_x <- pulse$time - pulse$time[1];
fit_temp_y <- pulse$conv_data;
fit_temp_z <- fit_temp_y+(0-min(fit_temp_y));
x <- fit_temp_x
z <- fit_temp_z
max_amp=max(fit_temp_z);
max_time=max(fit_temp_x);
opts.Lower <- c(0.5*max_amp, 0.3*max_amp, 0.1*max_amp, 0, 0, 0, 0.1*max_time, 0.1*max_time, 0.3*max_time)
opts.StartPoint <- list(a1 = 0.5*max_amp,
a2 = 0.5*max_amp,
a3 = 0.3*max_amp,
b1 = 0.5*max_time/8.65,
b2 = 0.5*max_time/8.65,
b3 = 0.5*max_time/5.7,
c1 = 0.2*max_time,
c2 = 0.3*max_time,
c3 = 0.65*max_time)
opts.Upper <- c(max_amp, max_amp, 0.8*max_amp, max_time/8.65, max_time/8.65, max_time/5.7, 0.3*max_time, 0.5*max_time, 1.0*max_time)
try(fit <- nls(formula = z ~ a1*exp(-0.5*((x-c1)/b1)^2)+
a2*exp(-0.5*((x-c2)/b2)^2)+
a3*exp(-0.5*((x-c3)/b3)^2),
#trace = T,
algorithm = "port",
start = opts.StartPoint,
control = nls.control(maxiter=1000, warnOnly = T),
lower = opts.Lower,
upper = opts.Upper))
# plot(x = fit_temp_x, y = fit_temp_z, type = "l")
# pred_z <- predict(fit, x)
# points(x, pred_z, type = "l", col = "red")
})
rsd <- c()
for(i in 1:length(pulse_segment_itr)){
xx <- pulse_segment_itr[[i]]
x <- xx$time - xx$time[1]
y <- xx$conv_data;
z <- y+(0-min(y))
pred_z <- predict(coef_itr[[i]], x)
pulse_segment_itr[[i]]$pred <- pred_z
coefs_itr <- coefficients(coef_itr[[i]])
pulse_segment_itr[[i]]$gau1 <- coefs_itr['a1']*exp(-0.5*((x-coefs_itr['c1'])/coefs_itr['b1'])^2)
pulse_segment_itr[[i]]$gau2 <- coefs_itr['a2']*exp(-0.5*((x-coefs_itr['c2'])/coefs_itr['b2'])^2)
pulse_segment_itr[[i]]$gau3 <- coefs_itr['a3']*exp(-0.5*((x-coefs_itr['c3'])/coefs_itr['b3'])^2)
corr <- cor(z, pred_z)
rsd <- c(rsd, corr*corr)
}
fit_pulse_segment_itr <- pulse_segment_itr[ !(rsd < 0.95)]
coef_itr <- coef_itr[ !(rsd < 0.95)]
# Use previous fit data to calculate P1 and align, instead of "alignsignals" command 05/18/17
gau1_peak_index <- sapply(fit_pulse_segment_itr, function(xx){
which(xx$gau1 == max(xx$gau1))
})
gau2_peak_index <- sapply(fit_pulse_segment_itr, function(xx){
which(xx$gau2 == max(xx$gau2))
})
gau3_peak_index <- sapply(fit_pulse_segment_itr, function(xx){
which(xx$gau3 == max(xx$gau3))
})
P1_diff <- sapply(fit_pulse_segment_itr, function(xx){diff(xx$conv_data)})
U1_diff <- sapply(fit_pulse_segment_itr, function(xx){abs(diff(xx$conv_data))})
P1_index <- c()
P1_height <- c()
notch_index <- c()
for(i in 1:length(fit_pulse_segment_itr)){
xx <- fit_pulse_segment_itr[[i]]
j = 0
for(p in gau1_peak_index[i]:gau2_peak_index[i]){
if(xx$gau1[p] >= xx$gau2[p] & xx$gau1[p+1] <= xx$gau1[p+2]){
j = p+1
break
}
}
if(j == 0){
j = gau1_peak_index[i] + 10;
}
if(length(which(P1_diff[[i]][(gau1_peak_index[i]-5):j] < 0 ))){
P1_ind = which(xx$conv_data == max(xx$conv_data[(gau1_peak_index[i]-5):j]))
} else {
for(p in (gau1_peak_index[i]-5):(gau2_peak_index[i]+50)){
if(P1_diff[[i]][p] < 0){
P1_ind = p-1;
break
}
}
}
if(!(exists("P1_ind"))){
P1_ind = gau2_peak_index[i]+50
}
P1_index <- c(P1_index, P1_ind)
P1_height <- c(P1_height, xx$conv_data[P1_index])
U1_diff_s=sort(U1_diff[[i]][gau2_peak_index[[i]]:min(c(length(U1_diff), gau3_peak_index[[i]]+round(0.1*nrow(xx))))]);
#***************add notch for scale 05/25/17
#*****Change from find minima in fit line to find minima in real data
for(p in gau2_peak_index[[i]]: min(c(gau3_peak_index[[i]]+100, length(U1_diff[[i]])))){
if(xx$conv_data[p-1]>=xx$conv_data[p] & U1_diff[[i]][p] %in% U1_diff_s[1:5]){
notch_ind <- p
break
}
}
if(!exists("notch_ind")){
notch_ind=gau3_peak_index[[i]]-100;
}
notch_index <- c(notch_index, notch_ind)
}
notch_index
fit_cof <- c()
for(i in 1:length(fit_pulse_segment_itr)){
fit_cof <- c(fit_cof, coefficients(coef_itr[[i]]))
}
fit_cof <- matrix(fit_cof, ncol = length(fit_pulse_segment_itr))
rownames(fit_cof) <- names(coefficients(coef_itr[[1]]))
#*******set a threshold of within +/- 1.5 SD for all the parameters
threshold <- rowMeans(fit_cof) + 1.5*rowSds(fit_cof)
threshold <- cbind(threshold, (rowMeans(fit_cof) - 1.5*rowSds(fit_cof)))
sel <- apply(fit_cof, 2, function(xx){all(xx < threshold[,1] & xx > threshold[,2]) & xx[1] > xx[3]})
fit_pulse_select <- fit_pulse_segment_itr[sel]
#plot(fit_pulse_select[[5]]$pred, type ="l")
notch_time  <- notch_index[sel] - P1_index[sel]
notch_time
gau2_peak_index
gau2_peak_index[[i]]
gau2_peak_index[i]
gau3_peak_index[i]
gau3_peak_index[i]+100
U1_diff[[i]]
length(U1_diff[[i]]))
length(U1_diff[[i]])))
length(U1_diff[[i]])
gau3_peak_index[i]+100
min(c(gau3_peak_index[i]+100, length(U1_diff[[i]])))
gau2_peak_index[i]
U1_diff[[i]][p]
U1_diff_s[1:5]
gau3_peak_index
notch_ind
notch_index <- c()
for(i in 1:length(fit_pulse_segment_itr)){
notch_ind <- c()
xx <- fit_pulse_segment_itr[[i]]
j = 0
for(p in gau1_peak_index[i]:gau2_peak_index[i]){
if(xx$gau1[p] >= xx$gau2[p] & xx$gau1[p+1] <= xx$gau1[p+2]){
j = p+1
break
}
}
if(j == 0){
j = gau1_peak_index[i] + 10;
}
if(length(which(P1_diff[[i]][(gau1_peak_index[i]-5):j] < 0 ))){
P1_ind = which(xx$conv_data == max(xx$conv_data[(gau1_peak_index[i]-5):j]))
} else {
for(p in (gau1_peak_index[i]-5):(gau2_peak_index[i]+50)){
if(P1_diff[[i]][p] < 0){
P1_ind = p-1;
break
}
}
}
if(!(exists("P1_ind"))){
P1_ind = gau2_peak_index[i]+50
}
P1_index <- c(P1_index, P1_ind)
P1_height <- c(P1_height, xx$conv_data[P1_index])
U1_diff_s=sort(U1_diff[[i]][gau2_peak_index[i]:min(c(length(U1_diff), gau3_peak_index[[i]]+round(0.1*nrow(xx))))]);
#***************add notch for scale 05/25/17
#*****Change from find minima in fit line to find minima in real data
for(p in gau2_peak_index[i]: min(c(gau3_peak_index[i]+100, length(U1_diff[[i]])))){
if(xx$conv_data[p-1]>=xx$conv_data[p] & U1_diff[[i]][p] %in% U1_diff_s[1:5]){
notch_ind <- p
break
}
}
if(!exists("notch_ind")){
notch_ind=gau3_peak_index[[i]]-100;
}
notch_index <- c(notch_index, notch_ind)
}
notch_index
notch_index
notch_ind <- c()
notch_ind == c()
isempty(notch_ind)
notch_index <- c()
for(i in 1:length(fit_pulse_segment_itr)){
notch_ind <- c()
xx <- fit_pulse_segment_itr[[i]]
j = 0
for(p in gau1_peak_index[i]:gau2_peak_index[i]){
if(xx$gau1[p] >= xx$gau2[p] & xx$gau1[p+1] <= xx$gau1[p+2]){
j = p+1
break
}
}
if(j == 0){
j = gau1_peak_index[i] + 10;
}
if(length(which(P1_diff[[i]][(gau1_peak_index[i]-5):j] < 0 ))){
P1_ind = which(xx$conv_data == max(xx$conv_data[(gau1_peak_index[i]-5):j]))
} else {
for(p in (gau1_peak_index[i]-5):(gau2_peak_index[i]+50)){
if(P1_diff[[i]][p] < 0){
P1_ind = p-1;
break
}
}
}
if(!(exists("P1_ind"))){
P1_ind = gau2_peak_index[i]+50
}
P1_index <- c(P1_index, P1_ind)
P1_height <- c(P1_height, xx$conv_data[P1_index])
U1_diff_s=sort(U1_diff[[i]][gau2_peak_index[i]:min(c(length(U1_diff), gau3_peak_index[[i]]+round(0.1*nrow(xx))))]);
#***************add notch for scale 05/25/17
#*****Change from find minima in fit line to find minima in real data
for(p in gau2_peak_index[i]: min(c(gau3_peak_index[i]+100, length(U1_diff[[i]])))){
if(xx$conv_data[p-1]>=xx$conv_data[p] & U1_diff[[i]][p] %in% U1_diff_s[1:5]){
notch_ind <- p
break
}
}
if(isempty(notch_ind)){
notch_ind=gau3_peak_index[[i]]-100;
}
notch_index <- c(notch_index, notch_ind)
}
notch_index
notch_time  <- notch_index[sel] - P1_index[sel]
notch_time
notch_index*t_unit
ave_PNtime <- notch_index*t_unit
ave_PP=mean(P1_height);
ave_temp <- rep(0, times = 1500)
ave_temp[250:(250+length(fit_pulse_select[[1]]$data)-1)]=fit_pulse_select[[1]]$data-fit_pulse_select[[1]]$data[1];
ave_temp
plot(ave_temp)
PN.sf <- ave_PNtime/notch_time
ave_PNtime
notch_time
ave_PNtime <- mean(notch_index*t_unit)
PN.sf <- ave_PNtime/(notch_index*t_unit)
PN.sf
plot(fit_pulse_select[[1]], col = col[1], type = "l")
col[1]
col
cols
colors <- rainbow(n = length(fit_pulse_segment_itr))
plot(fit_pulse_select[[1]], col = colors[1], type = "l")
plot(fit_pulse_select[[1]]$conv_data, type = "l", col = colors[1])
plot(fit_pulse_select[[1]]$conv_data, type = "l", col = colors[1])
for(i in 2:length(fit_pulse_select)){
points(fit_pulse_select[[i]]$conv_data, type = "l", col = colors[i])
}
plot(fit_pulse_select[[1]]$conv_data, type = "l", col = colors[1], ylim = 200)
for(i in 2:length(fit_pulse_select)){
points(fit_pulse_select[[i]]$conv_data, type = "l", col = colors[i])
}
plot(fit_pulse_select[[1]]$conv_data, type = "l", col = colors[1], ylim = c(-50,200))
for(i in 2:length(fit_pulse_select)){
points(fit_pulse_select[[i]]$conv_data, type = "l", col = colors[i])
}
plot(fit_pulse_select[[1]]$conv_data, type = "l", col = colors[1], ylim = c(-50,200))
for(i in 2:length(fit_pulse_select)){
points(fit_pulse_select[[i]]$conv_data, type = "l", col = colors[i])
}
colors
colors <- rainbow(100)
plot(fit_pulse_select[[1]]$conv_data, type = "l", col = colors[1], ylim = c(-50,200))
for(i in 2:length(fit_pulse_select)){
points(fit_pulse_select[[i]]$conv_data, type = "l", col = colors[i])
}
PN.sf
ave_PNtime <- mean(notch_index)
PN.sf <- ave_PNtime/notch_index
PN.sf
gau1_peak_index
unlink('S:/Users/Zhen/Scripts/zhenli.name/index_cache', recursive = TRUE)
unlink('S:/Users/Zhen/Scripts/zhenli.name/index_cache', recursive = TRUE)
unlink('S:/Users/Zhen/Scripts/zhenli.name/index_cache', recursive = TRUE)
rmarkdown::render_site()
setwd("~/zhen/scripts/zhenli.name/")
setwd("~/zhen/scripts/zhenli.name/")
library(DT)
install.packages("DT")
install.packages("openxlsx")
library(DT)
install.packages("htmltools")
upgrade()
install.packages("blogdown")
setwd("/Users/Zhen/zhenli.name/")
blogdown::serve_site()
blogdown::build_site()
install.packages("DT")
blogdown::build_site()
install.packages("openxlsx")
blogdown::build_site()
